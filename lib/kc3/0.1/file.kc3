## kc3
## Copyright from 2022 to 2025 kmx.io <contact@kmx.io>
##
## Permission is hereby granted to use this software granted the above
## copyright notice and this permission paragraph are included in all
## copies and substantial portions of this software.
##
## THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
## PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
## AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
## THIS SOFTWARE.

require File.Stat

defmodule File do

  def access? = cfn Bool "kc3_file_access" (Str, Sym)

  def close = cfn Void "file_close" (Tag)

  def dirname = cfn Str "file_dirname" (Str, Result)

  # ensure_directory(path, mode) => success
  def ensure_directory = cfn Bool "file_ensure_directory" (Str, Tag)

  # ensure_parent_directory(path, mode) => success
  def ensure_parent_directory = cfn Bool "file_ensure_directory" (Str,
    Tag)

  def exists? = cfn Bool "file_exists" (Str, Result)

  def ext = cfn Str "file_ext" (Str, Result)

  def is_directory? = cfn Bool "file_is_directory" (Str, Result)

  # link(old, new) => success
  def link = cfn Bool "file_link" (Str, Str)

  def list = cfn List "file_list" (Str, Result)

  def list_recursive = cfn List "file_list_recursive" (Str, Result)

#  def list_recursive = fn {
#    (dir) { list_recursive(dir, "", []) }
#    ([], dir, acc) { List.sort(acc) }
#    ([file | rest], dir, acc) {
#      if (Str.starts_with?(file, ".") ||
#          Str.ends_with?(file, "~"))
#        list_recursive(rest, dir, acc) # skip
#      else
#        path = dir + file
#        if (File.is_directory?(path)) do
#          acc2 = list_recursive(File.list(path), path + "/", acc)
#          list_recursive(rest, dir, acc2)
#        else
#          list_recursive(rest, dir, [path | acc])
#        end
#      end
#    }
#    (path, dir, acc) {
#      if (File.is_directory?(path)) do
#        list_recursive(File.list(path), path + "/", acc)
#      else
#        list_recursive(rest, dir, [path | acc])
#      end
#    }
#  }

  def name = cfn Str "file_name" (Str, Result)

  def open_r = cfn S32 "file_open_r" (Str, Result)

  def sha1_base64url = cfn Str "file_sha1_base64url" (Str, Result)

  def sha512_base64url = cfn Str "file_sha512_base64url" (Str, Result)

  def stat = cfn File.Stat "file_stat" (Str, Result)

  def size = fn (path) {
    st = stat(path)
    st.st_size
  }

  def read_all = cfn Str "file_read_all" (Str, Result)

  def read_max_cfn = cfn Str "file_read_max" (Str, Uw, Result)

  def read_max = fn (path, max) do
    File.read_max_cfn(path, (Uw) max)
  end

  def read_slice_cfn = cfn Str "file_read_slice" (Str, U64, U64, Result)

  def read_slice = fn (path, start, end_) do
    File.read_slice_cfn(path, (U64) start, (U64) end_)
  end

  # rename(old, new) => success
  def rename = cfn Bool "file_rename" (Str, Str)

  def unlink = cfn Bool "file_unlink" (Str)

  def which = fn (name) {
    if name do
      if Str.starts_with?(name, "/") do
        name
      else
        if path = getenv("PATH") do
          path_list = Str.split(path, ":")
          while path_list != [] do
            [dir | rest] = ^ path_list
            pathname = if Str.ends_with?(dir, "/") do
              "#{dir}#{name}"
            else
              "#{dir}/#{name}"
            end
            if File.access?(pathname, :x) do
              return pathname
            end
            path_list = ^ rest
          end
        end
        void
      end
    end
  }

  def write_str = cfn Sw "file_write_str" (Str, Str)

end
