defmodule HTTPd do

  require File
  require Socket
  require Socket.Buf
  require Str
  require HTTP
  require HTTP.Event
  require HTTP.Request
  require HTTP.Response

  def root_dir = "./public"

  def http_client = fn (socket, events, client_ev, client) do
    puts("echo_client")
    if List.has?(events, :read) do
      server_client(client)
    end
  end

  def acceptor = fn (server_socket, events, acceptor_ev, void) do
    if List.has?(events, :read) do
      puts("acceptor: read")
      client = Socket.Buf.accept(%Socket{fd: server_socket})
      puts("acceptor: got client")
      client_ev = HTTP.Event.new(event_base, client.sockfd, [:read, :persist],
        http_client, client)
      r = HTTP.Event.add(client_ev, timeout)
      puts("HTTP.Event.add: #{r}")
    end
  end

  def server = fn (host, port) {
    timeout = %Time{tv_sec: (Sw) 30}
    event_base = HTTP.Event.base_new()
    socket = Socket.listen(host, port)
    puts("KC3 HTTPd: listening on #{host}:#{port}")
    puts("socket.fd: #{socket.fd}")
    puts("event_base: #{event_base}")
    acceptor_ev = HTTP.Event.new(event_base, socket.fd, [:read, :persist],
                                 acceptor, void)
    puts("acceptor_ev: #{acceptor_ev}")
    r = HTTP.Event.add(acceptor_ev, timeout)
    puts("HTTP.Event.add: #{r}")
    r = HTTP.Event.dispatch(event_base)
    if r do
      e = errno()
      puts("HTTP.Event.dispatch: #{r}: #{strerror(e)}")
    end
    Socket.close(%Socket{fd: socket})
  }

  def server_client = fn (client) {
    puts("HTTPd.server_loop: got client #{client}")
    req = HTTP.Request.buf_parse(client.buf_rw.r)
    if req do
      router = route_request(req)
      res = router(req)
      HTTP.Response.buf_write(res, client.buf_rw.w, req.method != :head)
    end
  }

  def main = fn {
    () {
      HTTP.mime_type_load("mime.types")
      host = getenv("KC3_HTTPD_HOST")
      port = getenv("KC3_HTTPD_PORT")
      event_base = HTTP.Event.init();
      server(host, port)
    }
    (host, port) {
      HTTP.mime_type_load("mime.types")
      server(host, port)
    }
  }

  def debug_page = fn (request) {
    body = "<html>
  <head>
    <title>KC3 HTTPd</title>
    <style>
      pre {
        white-space: pre-wrap; /* CSS3 */
        white-space: -moz-pre-wrap; /* Mozilla */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: -o-pre-wrap; /* Opera 7 */
        word-wrap: break-word; /* Internet Explorer 5.5+ */
      }
    </style>
  </head>
  <body>
    <h1>KC3 HTTPd</h1>
    <p>
      Hello from #{__FILE__}
    </p>
    <h2>Request</h2>
    <pre><code>#{req}</code></pre>
  </body>
</html>
"
    %HTTP.Response{body: body}
  }

  def error_404_page = fn (request) {
    body = "<html>
  <head>
    <title>404 Not Found</title>
  </head>
  <body>
    <h1>404 Not Found</h1>
    <p>
      The requested URL #{request.url} was not found on this server.
    </p>
  </body>
</html>
"
    %HTTP.Response{code: 404, body: body}
  }

  def directory_page = fn (request) {
    files = File.list(root_dir + request.url)
    file_li = HTTPd.fn (file) {
      slash = if Str.ends_with?(request.url, "/") do "" else "/" end
      real_path = "#{root_dir}#{request.url}#{slash}#{file}"
      dir? = File.is_directory?(real_path)
      path = "#{request.url}#{slash}#{file}"
      mode = if dir? do "dr-xr-xr-x" else "-r--r--r--" end
      "<li>#{mode} <a href=\"#{path}\">#{path}</a></li>"
    }
    body = """<html>
  <head>
    <title>Index of #{request.url}</title>
    <style type="text/css">
      ul { font-family: monospace; }
    </style>
  </head>
  <body>
    <h1>Index of #{request.url}</h1>
    <ul>
      #{str(List.map(files, file_li))}
    </ul>
  </body>
</html>
"""
    %HTTP.Response{body: body}
  }

  def show_page = fn (request) {
    ext = File.ext(request.url)
    path = root_dir + request.url
    if File.exists?(path) do
      body = File.read(path)
      mime = HTTP.mime_type(ext)
      puts("HTTPd.show_page: mime = #{mime}")
      headers = [{"Content-Type", (Str) mime}]
      %HTTP.Response{body: body, headers: headers}
    else
      error_404_page(request)
    end
  }

  def route_request = fn (request) {
    path = root_dir + request.url
    if File.exists?(path) do
      if File.is_directory?(path) do
        directory_page
      else
        show_page
      end
    else
      error_404_page
    end
  }

end
