## kc3
## Copyright from 2022 to 2026 kmx.io <contact@kmx.io>
##
## Permission is hereby granted to use this software granted the above
## copyright notice and this permission paragraph are included in all
## copies and substantial portions of this software.
##
## THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
## PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
## AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
## THIS SOFTWARE.

require Buf
require Event
require Facts
require File
require HTML
require HTTP
require HTTP.Request
require HTTP.Response
require HTTPd.Route
require KQueue
require Socket
require Socket.Buf
require Str
require Thread
require URL

defmodule HTTPd do

  def kq_fd = ?
  def kq_mutex = Mutex.new()

  defcounter HTTPd.connections = 0
  def connections_max = ncpu * 16

  def load_app = fn () {
    HTTP.mime_type_load("config/mime.types")
    load_directory!("app/lib/")
    load_directory!("app/models/")
    if (File.exists?("config/app.kc3")) do
      load!("config/app.kc3")
    end
    if (File.exists?("config/db.kc3")) do
      load!("config/db.kc3")
    end
    load_directory!("app/views/")
    load_directory!("app/controllers/")
    if (File.exists?("config/routes.kc3")) do
      load!("config/routes.kc3")
    end
    load_directory!("app/plugs/")
    if (File.exists?("config/unveil.kc3")) do
      load!("config/unveil.kc3")
    end
    securelevel(2)
    IO.puts("HTTPd.load_app: done")
  }

  def clean_upload = fn (file) {
    if (file != "." && file != "..") do
      path = HTTP.Upload.tmp_filename_prefix + file
      IO.puts("HTTPd.clean_all_uploads: RM #{inspect(path)}")
      File.unlink(path)
    end
  }

  def clean_all_uploads = fn () {
    if (File.exists?(HTTP.Upload.tmp_filename_prefix)) do
      List.each(File.list(HTTP.Upload.tmp_filename_prefix),
        HTTPd.clean_upload)
    end
  }

  def clean_request_uploads = fn (params) {
    if params do
      List.each(params, fn {
        ({key, value}) {
          if ((type(value) == HTTP.Upload) &&
              Str.starts_with?(value.tmp_path,
                HTTP.Upload.tmp_filename_prefix) &&
              File.exists?(value.tmp_path)) do
            IO.puts("HTTPd.clean_request_uploads: RM #{inspect(value.tmp_path)}")
            File.unlink(value.tmp_path)
          end
        }
        (_) { }
      })
    end
  }

  clients = %{}

  def http_client = fn (socket, client) do
    close = false
    error = true
    unwind_protect(do
      request = HTTP.Request.buf_parse(client.buf_rw.r)
      if request do
        client_addr = if client.addr_str != "127.0.0.1" do
          client.addr_str
        else
          headers = request.headers
          real_ip = headers["X-Real-IP"]
          if (real_ip) do real_ip else client.addr_str end
        end
        request = Struct.put(request, :client_addr, client_addr)
        user_agent = HTTP.Request.header(request, "User-Agent")
        IO.puts("--- #{client_addr} #{request.method} #{request.url} #{inspect(user_agent)} #{Time.to_str(request.time)}")
        if (type(request.method) == Str) do
          response = error_405_page(request)
        else
          request = plug_request(request)
          response = route_and_render_request(request)
        end
        clean_request_uploads(request.body)
        connection = HTTP.Request.header(request, "Connection") || ""
        if Compare.str_case_insensitive(connection, "close") == 0 do
          close = true
          response = HTTP.Response.set_header(response,
            "Connection", "close")
        else
          response = HTTP.Response.set_header(response,
            "Connection", "keep-alive")
          response = HTTP.Response.set_header(response,
            "Keep-Alive", "timeout=5, max=10")
        end
        response = HTTP.Response.set_header(response,
          "Server", "kc3_httpd")
        response = HTTP.Response.set_header(response,
          "Accept-Ranges", "bytes")
        r = HTTP.Response.buf_write(response, client.buf_rw.w,
          request.method != HEAD)
        error = ((r <= 0) || (KQueue.add(HTTPd.kq_fd, client.sockfd,
                               HTTPd.timeout, {:client, client}) != 0))
        dt = Time.now() - request.time
        dt_str = Time.diff_to_str(dt)
        IO.puts("#{response.code} #{client_addr} #{request.method}" +
          " #{request.url} #{inspect(user_agent)}" +
          " #{dt_str}")
        if (response.code >= 400) do
          Err.puts("#{response.code} #{client_addr} #{request.method}" +
            " #{request.url} #{inspect(user_agent)}" +
            " #{dt_str}")
        end
      end
    end, do
      if error || close do
        Socket.Buf.close(client)
        File.close(socket)
        if ! close do
          Counter.decrease(HTTPd.connections, 1)
          count = Counter.get(HTTPd.connections)
          puts("HTTPd.http_client: connections=#{count}")
        end
      end
    end)
  end

  def timeout = %Time{tv_sec: 5}

  def acceptor = fn (server_socket) {
    ok = false
    client = void
    unwind_protect(do
      if (Counter.get(HTTPd.connections) < HTTPd.connections_max) &&
         (client = Socket.Buf.accept(%Socket{fd: server_socket})) do
        Counter.increase(HTTPd.connections, 1)
        count = Counter.get(HTTPd.connections)
        puts("HTTPd.acceptor: connections=#{count}")
        Mutex.lock(HTTPd.kq_mutex)
        unwind_protect(do
          ok = (KQueue.add(HTTPd.kq_fd, server_socket, void, :acceptor) == 0 &&
                KQueue.add(HTTPd.kq_fd, client.sockfd, HTTPd.timeout, {:client, client}) == 0)
        end, do
          Mutex.unlock(HTTPd.kq_mutex)
        end)
      end
    end, do
      if ((! ok) && client) do
        Socket.Buf.close(client)
        File.close(client.sockfd)
      end
    end)
  }

  def daemonize = fn () {
    if KC3.daemonize do
      IO.puts("forking to background")
      if (pid = fork()) > 0 do
        exit_subprocess(0)
      end
    end
  }

  def server_thread = fn () {
    run = true
    while run do
      Mutex.lock(HTTPd.kq_mutex)
      r = unwind_protect(do
        KQueue.poll(HTTPd.kq_fd, %Time{})
      end, do
        Mutex.unlock(HTTPd.kq_mutex)
      end)
      match r do
        {sockfd, :eof, :acceptor} ->
          File.close(sockfd)
          run = false
        {sockfd, :read, :acceptor} ->
          HTTPd.acceptor(sockfd)
        {sockfd, :eof, {:client, client}} ->
          if Socket.Buf.can_close?(client) do
            KQueue.delete(HTTPd.kq_fd, sockfd, :timer)
            Socket.Buf.close(client)
            File.close(sockfd)
            Counter.decrease(HTTPd.connections, 1)
            count = Counter.get(HTTPd.connections)
            puts("HTTPd.server_thread: eof: connections=#{count}")
          end
        {sockfd, :read, {:client, client}} ->
          HTTPd.http_client(sockfd, client)
        {sockfd, :timer, {:client, client}} ->
          if Socket.Buf.can_close?(client) do
            KQueue.delete(HTTPd.kq_fd, sockfd, :read)
            Socket.Buf.close(client)
            File.close(sockfd)
            Counter.decrease(HTTPd.connections, 1)
            count = Counter.get(HTTPd.connections)
            puts("HTTPd.server_thread: timeout: connections=#{count}")
          end
        void ->
          sleep(%Time{tv_nsec: 10000000})
        x ->
          Err.puts("HTTPd.server_thread: unknown poll value:" +
            " #{inspect(x)}")
          void
      end
    end
  }

  def server_thread_new = fn (x) {
    Thread.new(HTTPd.server_thread)
  }

  #def thread_count = 1
  def thread_count = ncpu

  def socket = ?

  def server = fn (host, port) {
    unveil("./", "r")
    unveil("./db/", "crw")
    if File.exists?("./upload/") do
      unveil("./upload/", "crw")
      List.each(File.list("./upload/"), fn (name) {
        path = "./upload/#{name}"
        if File.is_directory?(path) do
          unveil(path, "crw")
        end
      })
    end
    unveil("/etc/resolv.conf", "r")
    unveil("/etc/ssl", "r")
    if Module.has_symbol?(Config, :unveil) do
      Config.unveil()
    end
    unveil("", "")
    pledge("stdio rpath wpath cpath fattr inet dns proc", "")
    if HTTPd.socket <- Socket.listen(host, port) do
      daemonize()
      pledge("stdio rpath wpath cpath fattr inet dns", "")
      IO.puts("KC3 HTTPd: listening on #{host}:#{port}")
      clean_all_uploads()
      if (HTTPd.kq_fd <- KQueue.kqueue()) > 0 do
        KQueue.add(HTTPd.kq_fd, socket.fd, void, :acceptor)
        if HTTPd.thread_count > 1 do
          threads = List.map(List.count(HTTPd.thread_count - 1),
            HTTPd.server_thread_new)
          HTTPd.server_thread()
          List.map(threads, Thread.delete)
        else
          HTTPd.server_thread()
        end
        0
      else
        Err.puts("KC3 HTTPd: KQueue.kqueue")
        -1
      end
    else
      Err.puts("KC3 HTTPd: cannot listen on #{host}:#{port}")
      -1
    end
  }

  def main = fn {
    () {
      host = getenv("KC3_HTTPD_HOST")
      port = getenv("KC3_HTTPD_PORT")
      server(host, port)
    }
    (host, port) {
      server(host, port)
    }
  }

  def redirect_to = fn (url) {
    %HTTP.Response{code: 303,
                   message: "See other",
                   headers: [{"Location", URL.escape(url)}],
                   body: ""}
  }

  def debug_page = fn (request) {
    body = "<html>
  <head>
    <title>KC3 HTTPd</title>
    <style>
      pre {
        white-space: pre-wrap; /* CSS3 */
        white-space: -moz-pre-wrap; /* Mozilla */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: -o-pre-wrap; /* Opera 7 */
        word-wrap: break-word; /* Internet Explorer 5.5+ */
      }
    </style>
  </head>
  <body>
    <h1>KC3 HTTPd</h1>
    <p>
      Hello from #{__FILE__}
    </p>
    <h2>Request</h2>
    <pre><code>#{request}</code></pre>
  </body>
</html>
"
    %HTTP.Response{body: body}
  }

  def error_400_page = fn (request) {
    body = """
<html>
  <head>
    <title>400 Bad Request</title>
  </head>
  <body>
    <h1>400 Bad Request</h1>
    <p>
      The request is invalid and could not be treated by the server.
    </p>
  </body>
</html>
"""
    %HTTP.Response{code: 400, body: body}
  }

  def error_404_page = fn (request) {
    body = """
<html>
  <head>
    <title>404 Not Found</title>
  </head>
  <body>
    <h1>404 Not Found</h1>
    <p>
      The requested URL #{HTML.escape(inspect(request.url))} for method #{HTML.escape(inspect(request.method))} was not found on this server.
    </p>
  </body>
</html>
"""
    %HTTP.Response{code: 404, body: body}
  }

  def error_405_page = fn (request) {
    body = """
<html>
  <head>
    <title>405 Method Not Allowed</title>
  </head>
  <body>
    <h1>405 Method Not Allowed</h1>
    <p>
      The requested method #{HTML.escape(inspect(request.method))} is not accepted on this server.
    </p>
  </body>
</html>
"""
    %HTTP.Response{code: 405, body: body}
  }

  def plugs = []

  def def_plug = fn (plug) {
    tmp = List.append_one(HTTPd.plugs, plug)
    def HTTPd.plugs = tmp
  }

  def plug_request = fn {
    (request) { plug_request(request, plugs) }
    (request, []) { request }
    (request, [plug | rest]) { plug_request(plug(request), rest) }
  }

  def routes = []

  def def_route = fn (path, controller) {
    Facts.with_transaction(Facts.env_db(), do
      tmp = List.append_one(HTTPd.routes,
        %HTTPd.Route{path: path,
                     controller: controller})
      def HTTPd.routes = tmp
    end)
  }

  def route_and_render_request = fn {
    (request) {
      route_and_render_request(request, routes)
    }
    (request, []) {
      error_404_page(request)
    }
    (request, [route | next_routes]) {
      response = if (controller = HTTPd.Route.match(route, request)) do
        let(request.params, controller(request))
      end
      response || route_and_render_request(request, next_routes)
    }
  }

  def parse_range = fn {
    (false, max) { { (Sw) 0, (Sw) max } }
    (range, max) {
      if Str.starts_with?(range, "bytes=") do
        range = Str.slice(range, 6, -1)
        [start, end_] = Str.split(range, "-")
        if start do
          start = (Sw) start
          end_ = if end_ != "" do
            (Sw) end_
          else
            (Sw) max
          end
          { start, end_ }
        else
          { (Sw) 0, (Sw) max }
        end
      else
        { (Sw) 0, (Sw) max }
      end
    }
  }

  HTTPd.Route.def_static_route("", "./static/", 0)

end
