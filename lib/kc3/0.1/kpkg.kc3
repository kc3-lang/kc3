## kc3
## Copyright from 2022 to 2025 kmx.io <contact@kmx.io>
##
## Permission is hereby granted to use this software granted the above
## copyright notice and this permission paragraph are included in all
## copies and substantial portions of this software.
##
## THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
## PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
## AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
## THIS SOFTWARE.

require Counter
require FD
require File
require IO
require Kpkg.Package
require Sh
require Terminal

# Kpkg

defmodule Kpkg do

  ## Configuration

  def cc_local = fn () {
    pathname = File.which(getenv("CC_LOCAL")) ||
      File.which("cc") || File.which("clang") ||
      File.which("gcc")
    if File.access?(pathname, :x) do
      pathname
    else
      puts("Please set CC_LOCAL to a valid local C compiler")
      exit(1)
    end
  }

  def cc = fn {
    () {
      cc_local()
    }
    (arch) {
      if arch == Kpkg.arch_local() do
        return cc_local()
      else
        pathname = File.which(getenv("CC"))
        if File.access?(pathname, :x) do
          pathname
        else
          puts("Please set CC to a valid target C compiler")
          exit(1)
        end
      end
    }
  }

  def color? = false

  def cxx_local = fn () {
    pathname = File.which(getenv("CXX_LOCAL")) ||
      File.which("c++") || File.which("clang++") ||
      File.which("g++")
    if File.access?(pathname, :x) do
      pathname
    else
      puts("Please set CXX_LOCAL to a valid local C++ compiler")
      exit(1)
    end
  }

  def cxx = fn {
    () {
      cxx_local()
    }
    (arch) {
      if arch == Kpkg.arch_local() do
        return cxx_local()
      else
        pathname = File.which(getenv("CXX"))
        if File.access?(pathname, :x) do
          pathname
        else
          puts("Please set CXX to a valid target C++ compiler")
          exit(1)
        end
      end
    }
  }

  def dir = fn () {
    dir = if from_env = getenv("KPKG_DIR") do
      from_env
    else
      if home = getenv("HOME") do
        "#{home}/kpkg/"
      end
    end
    if Str.ends_with?(dir, "/") do
      Str.slice(dir, 0, -2)
    else
      dir
    end
  }

  def db = Facts.database()

  def tmp = fn (name) {
    if (type(name) != Str || name[0] != '/') do
      puts("tmp: #{name}: invalid name")
      exit(1)
    end
    "#{Kpkg.dir()}/tmp#{name}"
  }

  def umask = 0o750

  def uname = fn () {
    {code, out_err} = system(["uname"])
    if (code) do
      puts(out_err)
      exit(1)
    end
    Str.slice(out_err, 0, -2);
  }

  ## Package definition

  def defpackage = fn (package) {
    Facts.add_tags(Kpkg.db, package.name, :is_a, Kpkg.Package)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_build_depends_on, package.build_depends_on)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_configure_options, package.configure_options)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_default_branch, package.default_branch)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_depends_on, package.depends_on)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_dir, package.dir)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git, package.git)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git_push, package.git_push)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_is_needed?, package.is_needed?)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_make, package.make)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_module, package.module)
  }

  def defalias = fn (name, target) {
    Facts.add_tags(db, name, :is_a, Kpkg.Package.Alias)
    Facts.add_tags(db, name, :kpkg_package_alias_target, target)
  }

  ## Package API

  def get_kpkg_package = fn (name) {
    Facts.first_with(db, [[name, :is_a, Kpkg.Package],
                          [name, :kpkg_package_build_depends_on,
                           build_depends_on = ?],
                          [name, :kpkg_package_configure_options,
                           configure_options = ?],
                          [name, :kpkg_package_default_branch,
                           default_branch = ?],
                          [name, :kpkg_package_depends_on,
                           depends_on = ?],
                          [name, :kpkg_package_dir, dir = ?],
                          [name, :kpkg_package_git, git = ?],
                          [name, :kpkg_package_git_push, git_push = ?],
                          [name, :kpkg_package_is_needed?, is_needed? = ?],
                          [name, :kpkg_package_make, make = ?],
                          [name, :kpkg_package_module, module = ?]],
      fn (fact) { %Kpkg.Package{name: name,
                                build_depends_on: build_depends_on,
                                configure_options: configure_options,
                                default_branch: default_branch,
                                depends_on: depends_on,
                                dir: dir,
                                git: git,
                                git_push: git_push,
                                is_needed?: is_needed?,
                                make: make,
                                module: module} })
  }
  
  def get_kpkg_package_alias = fn (name) {
    if name = Sym.find(name) do
      while (new_name = Facts.first_with_tags(db, name,
               :kpkg_package_alias_target, new_name = ?,
               fn (fact) { new_name })) do
        name = new_name
      end
      name
    end
  }

  def get_package = fn (name) {
    if name = get_kpkg_package_alias(name) do
      get_kpkg_package(name)
    end
  }

  def get_package_or_die = fn (name) {
    if ! (pkg = Kpkg.get_package(name)) do
      puts("kpkg: package not found: #{name}")
      exit(1)
    end
    pkg
  }

  ## Main entry point

  def main = fn {
    ([]) {
      Kpkg.usage()
      0
    }
    (["--color"]) {
      def Kpkg.color? = true
      Kpkg.usage()
      0
    }
    ([name | rest]) {
       Kpkg.load()
       pkg = Kpkg.get_package_or_die(name)
       main_args(pkg, rest)
     }
  }

  def load = fn () {
    File.ensure_directory(dir(), Kpkg.umask)
    Kpkg.Package.load_all()
  }

  ## Argument parsing

  def main_args = fn {
    (pkg, []) { puts(pkg) }
    (pkg, args) {
      tree = pkg.default_branch
      arch = Kpkg.arch_local()
      result = 0
      rest = ^ args
      while result == 0 && (args = ^ rest) != [] do
        match args do
          ["--arch", arch_arg | rest] ->
            arch = ^ arch_arg
          ["--branch", branch_arg | rest] ->
            tree = ^ branch_arg
          ["autogen" | rest] ->
            result = Kpkg.autogen(pkg, tree)
          ["autogen-clean" | rest] ->
            result = Kpkg.autogen_clean(pkg, tree)
          ["build" | rest] ->
            result = Kpkg.build(pkg, tree, arch)
          ["build-dependencies" | rest] ->
            puts(Kpkg.build_dependencies(pkg))
          ["checkout" | rest] ->
            result = Kpkg.checkout(pkg, tree)
          ["checkout-clean" | rest] ->
            result = Kpkg.checkout_clean(pkg, tree)
          ["clean" | rest] ->
            result = Kpkg.clean_pkg(pkg)
          ["clean-arch" | rest] ->
            result = Kpkg.clean_tree_arch(pkg)
          ["clean-tree" | rest] ->
            result = Kpkg.clean_tree(pkg)
          ["clone" | rest] ->
            result = Kpkg.clone(pkg)
          ["clone-clean" | rest] ->
            result = Kpkg.clone_clean(pkg)
          ["--color" | rest] ->
            def Kpkg.color? = true
          ["configure" | rest] ->
            result = Kpkg.configure(pkg, tree, arch)
          ["configure-clean" | rest] ->
            result = Kpkg.configure_clean(pkg, tree, arch)
          ["dependencies" | rest] ->
            puts(Kpkg.dependencies(pkg))
          ["fake" | rest] ->
            result = Kpkg.fake(pkg, tree, arch)
          ["fake-clean" | rest] ->
            result = Kpkg.fake_clean(pkg, tree, arch)
          ["info" | rest] ->
            result = Kpkg.info(pkg, tree, arch)
          ["install" | rest] ->
            result = Kpkg.install(pkg, tree, arch)
          ["install-build-deps" | rest] ->
            result = Kpkg.install_build_dependencies(pkg, tree)
          ["install-deps" | rest] ->
            result = Kpkg.install_dependencies(pkg, tree, arch)
          ["package" | rest] ->
            result = Kpkg.package(pkg, tree, arch)
          ["package-clean" | rest] ->
            result = Kpkg.package_clean(pkg, tree, arch)
          ["--tree", tree_arg | rest] ->
            tree = ^ tree_arg
          ["uninstall" | rest] ->
            result = Kpkg.uninstall(pkg, tree, arch)
          _ ->
            puts("kpkg: unknown argument: #{args}")
            result = 1
        end
      end
      result
    }
  }

  def usage = fn () {
    style? = Kpkg.style?()
    reset = if style? do "#{Terminal.reset}" end
    bold  = if style? do "#{Terminal.bold}" end
    title = if style? do "#{Terminal.bold}#{Terminal.fg_blue}" end
    puts("""
Usage: [KPKG_DIR=~/kpkg] #{bold}kpkg#{reset} PKG [OPTION â€¦] COMMAND [ARG â€¦] â€¦
ðŸ¢ #{title}Options :#{reset}
    --arch ARCH          build for $ARCH
    --branch BRANCH      work on tree $BRANCH (same as --tree)
    --color              enable text styling and colors
    --tree TREE          work on tree $TREE (same as --branch)
ðŸ¢ #{title}Source directory commands :#{reset}
    autogen              run autogen or bootstrap script
    autogen-clean        remove autogen stamp file
    checkout             git checkout $TREE into src/$DIR/$TREE
    checkout-clean       remove checkout files : src/$DIR/$TREE
    clone                git clone into git/$DIR
    clone-clean          remove git repo files: git/$DIR
ðŸ¢ #{title}Dependencies commands :#{reset}
    build-dependencies   show build-time dependencies
    dependencies         show dependencies
    install-build-deps   install build-time dependencies
    install-deps         install dependencies
ðŸ¢ #{title}Build commands :#{reset}
    configure            run configure in arch/$ARCH/obj/$DIR/$TREE
    configure-clean      remove configure-done tag
    build                run parallel build
    clean-build          remove object files
   #{title}Package commands :#{reset}
    fake                 fake installation just before packaging
    package              create manifest, package and checksum
   #{title}Install commands :#{reset}
    install              install package
ðŸ¢ #{title}Misc commands :#{reset}
    clean                remove all files related to $PKG
    clean-tree           remove all files related to $PKG $TREE
    clean-arch           remove all files related to $PKG $TREE $ARCH
    info                 show current state
""")
  }

  ## Package configuration

  def git_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{pkg.dir}.git"
  }

  def git_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{File.dirname(pkg.dir)}"
  }

  def src_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/src/#{pkg.dir}"
  }

  ## Tree configuration

  def src_dir = fn (pkg, tree) {
    "#{Kpkg.dir()}/src/#{pkg.dir}/#{tree}"
  }

  def cmake_path = fn (pkg, tree) {
    "#{Kpkg.src_dir(pkg, tree)}/CMakeLists.txt"
  }

  def configure_path = fn (pkg, tree) {
    "#{Kpkg.src_dir(pkg, tree)}/configure"
  }

  def meson_path = fn (pkg, tree) {
    "#{Kpkg.src_dir(pkg, tree)}/meson.build"
  }

  def meson_cross_file_path = fn (arch) {
    "#{Kpkg.dir()}/arch/#{arch}/meson-cross.ini"
  }

  def meson_cross_file_write = fn (arch, cc, cxx) {
    cross_file = Kpkg.meson_cross_file_path(arch)
    cross_dir = File.dirname(cross_file)
    File.ensure_directory(cross_dir, Kpkg.umask)
    arch_parts = Str.split(arch, "-")
    cpu_family = List.first(arch_parts)
    cpu = ^ cpu_family
    system = List.last(arch_parts)
    endian = "little"
    prefix = Kpkg.prefix_dir(arch)
    # Create pkg-config wrapper that uses PKG_CONFIG_LIBDIR
    pkg_config_wrapper = "#{cross_dir}/pkg-config-wrapper.sh"
    wrapper_content = """#!/bin/sh
export PKG_CONFIG_LIBDIR=#{prefix}/lib/pkgconfig
exec pkg-config "$@"
"""
    File.write_str(pkg_config_wrapper, wrapper_content)
    Kpkg.exec!(["chmod", "755", pkg_config_wrapper])
    content = """## gen by kpkg
[binaries]
c = '#{cc}'
cpp = '#{cxx}'
pkg-config = '#{pkg_config_wrapper}'

[properties]
sys_root = '#{prefix}'

[host_machine]
system = '#{system}'
cpu_family = '#{cpu_family}'
cpu = '#{cpu}'
endian = '#{endian}'
"""
    File.write_str(cross_file, content)
    cross_file
  }

  ## Arch configuration

  def arch_dir = fn {
    (pkg, tree, arch) {
      arch_dir(pkg, tree, arch, "src")
    }
    (pkg, tree, arch, subdir) {
      "#{Kpkg.dir()}/arch/#{arch}/#{subdir}/#{pkg.dir}/#{tree}"
    }
  }

  def arch_local = fn () {
    {code, out_err} = system(["env", "LC_ALL=C", Kpkg.cc_local(), "-v"])
    if (code) do
      puts("kpkg: arch_local: cc_local")
      puts(out_err)
      exit(1)
    end
    List.each(Str.split(out_err, "\n"), fn (line) {
      if Str.starts_with?(line, "Target: ") do
        return_from :arch_local Str.slice(line, 8, -1)
      end
    })
  }

  def build_dir = fn (pkg, tree, arch) {
    arch_dir(pkg, tree, arch, "obj")
  }

  def package_path = fn (pkg, tree, arch) {
    arch_dir(pkg, tree, arch, "pkg")
  }

  def prefix_dir = fn (arch) {
    "#{Kpkg.dir()}/arch/#{arch}/local"
  }

  def destdir = fn (pkg, tree, arch) {
    "#{Kpkg.dir()}/arch/#{arch}/destdir/#{pkg.dir}/#{tree}"
  }

  def installed_db_path = fn (pkg, tree, arch) {
    "#{Kpkg.dir()}/var/db/kpkg/installed/#{arch}/#{pkg.name}-#{tree}"
  }

  ## Internal API

  def exec! = fn (cmd) {
    style? = Kpkg.style?()
    reset = if style? do "#{Terminal.reset}" end
    style = if style? do "#{Terminal.bold}#{Terminal.fg_blue}" end
    cmd_str = List.join(cmd, " ")
    Kpkg.indent_puts("#{style}#{cmd_str}#{reset}")
    Kpkg.indent(1)
    match system(cmd) do
      {0, ""} ->
        Kpkg.indent(-1)
        Kpkg.indent_puts("#{style}#{cmd_str}: OK#{reset}")
        ""
      {0, out_err} ->
        if (Str.ends_with?(out_err, "\n")) do
          out_err = Str.slice(out_err, 0, -2)
        end
        List.each(Str.split(out_err, "\n"), fn (line) {
          Kpkg.indent_puts(line)
        })
        Kpkg.indent(-1)
        Kpkg.indent_puts("#{style}#{cmd_str}: OK#{reset}")
        out_err
      {code, out_err} ->
        if (Str.ends_with?(out_err, "\n")) do
          out_err = Str.slice(out_err, 0, -2)
        end
        List.each(Str.split(out_err, "\n"), fn (line) {
          Kpkg.indent_puts(line)
        })
        Kpkg.indent(-1)
        Kpkg.indent_puts("#{style}#{cmd_str}: ERROR#{reset}")
        exit(1)
      _ ->
        Kpkg.indent(-1)
        Kpkg.indent_puts("#{style}#{cmd_str}: ERROR: system#{reset}")
        exit(2)
    end
  }

  defcounter indent_level = 0

  def indent = fn (level) {
    if level > 0 do
      Counter.increase(Kpkg.indent_level, level)
    else
      Counter.decrease(Kpkg.indent_level, - level)
    end
  }

  def indent_puts = fn (msg) {
    spacer = "â”‚" * Counter.get(Kpkg.indent_level)
    style? = Kpkg.style?()
    reset = if style? do "#{Terminal.reset}" end
    color = if style? do "#{Terminal.fg_light_gray}" end
    puts("#{color}#{spacer}#{reset}#{msg}")
  }

  def log_call = fn (msg) {
    style? = Kpkg.style?()
    reset = if style? do "#{Terminal.reset}" end
    style = if style? do "#{Terminal.bold}#{Terminal.fg_magenta}" end
    Kpkg.indent_puts("#{style}#{msg}#{reset}")
  }

  def style? = fn () {
    FD.is_a_tty?(1) || Kpkg.color?
  }

  ## Main API - sources from git

  def autogen = fn (pkg, tree) {
    Kpkg.log_call("autogen #{pkg.name} #{tree}")
    Kpkg.indent(1)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    pkg_src_dir_sh = Sh.escape(pkg_src_dir)
    stamp_file = pkg_src_dir + "/.kpkg_autogen"
    if ! File.exists?(stamp_file) do
      File.write_str(stamp_file, "false\n")
      Kpkg.checkout(pkg, tree)
      cc_sh = Sh.escape(Kpkg.cc_local())
      if File.exists?(pkg_src_dir + "/autogen.sh") do
        Kpkg.exec!(["/bin/sh", "-c", "cd #{pkg_src_dir_sh} && CC=#{cc_sh} NOCONFIGURE=1 /bin/sh autogen.sh"])
      else
        if File.exists?(pkg_src_dir + "/autogen") do
          Kpkg.exec!(["/bin/sh", "-c", "cd #{pkg_src_dir_sh} && CC=#{cc_sh} /bin/sh autogen"])
        else
          bootstrap = pkg_src_dir + "/bootstrap"
          if File.exists?(bootstrap) do
            Kpkg.exec!(["sh", "-c", "cd #{pkg_src_dir_sh} && CC=#{cc_sh} ./bootstrap"])
          else
            puts("kpkg: no autogen or boostrap files found")
          end
        end
      end
      File.write_str(stamp_file, "true\n")
    end
    Kpkg.indent(-1)
    Kpkg.log_call("autogen #{pkg.name} #{tree}: OK")
    0
  }

  def autogen_clean = fn (pkg, tree) {
    Kpkg.log_call("autogen_clean #{pkg.name} #{tree}")
    Kpkg.indent(1)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    stamp_file = pkg_src_dir + "/.kpkg_autogen"
    if File.exists?(stamp_file) do
      Kpkg.exec!(["rm", "-f", stamp_file])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("autogen_clean #{pkg.name} #{tree}: OK")
    0
  }

  def checkout = fn (pkg, tree) {
    Kpkg.log_call("checkout #{pkg.name} #{tree}")
    Kpkg.indent(1)
    Kpkg.clone(pkg)
    pkg_git_dir = Kpkg.git_dir(pkg)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if ! File.exists?(pkg_src_dir + "/.kpkg_autogen") do
      if ! File.is_directory?(pkg_src_dir) do
        Kpkg.exec!(["mkdir", "-p", Kpkg.src_parent_dir(pkg)])
        Kpkg.exec!(["git", "clone", "-b", tree, pkg_git_dir, pkg_src_dir])
      else
        Kpkg.exec!(["git", "-C", pkg_src_dir, "pull"])
      end
      Kpkg.exec!(["git", "-C", pkg_src_dir, "submodule", "init"])
      Kpkg.exec!(["git", "-C", pkg_src_dir, "submodule", "update",
                  "--recursive", "--remote"])
      Kpkg.autogen(pkg, tree)
    end
    Kpkg.indent(-1)
    Kpkg.log_call("checkout #{pkg.name} #{tree}: OK")
    0
  }

  def checkout_clean = fn (pkg, tree) {
    Kpkg.log_call("checkout_clean #{pkg.name} #{tree}")
    Kpkg.indent(1)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.is_directory?(pkg_src_dir) do
      Kpkg.exec!(["rm", "-rf", pkg_src_dir])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("checkout_clean #{pkg.name} #{tree}: OK")
    0
  }

  def clone = fn (pkg) {
    Kpkg.log_call("clone #{pkg.name}")
    Kpkg.indent(1)
    pkg_git_dir = Kpkg.git_dir(pkg)
    if ! File.is_directory?(pkg_git_dir) do
      Kpkg.exec!(["mkdir", "-p", Kpkg.git_parent_dir(pkg)])
      # TODO: --bare ?
      Kpkg.exec!(["git", "clone", "--bare", "--mirror", pkg.git,
                  pkg_git_dir])
    else
      Kpkg.exec!(["git", "-C", pkg_git_dir, "fetch", "--all"])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("clone #{pkg.name}: OK")
    0
  }

  def clone_clean = fn (pkg) {
    Kpkg.log_call("clone_clean #{pkg.name}")
    Kpkg.indent(1)
    pkg_git_dir = Kpkg.git_dir(pkg)
    if File.is_directory?(pkg_git_dir) do
      Kpkg.exec!(["rm", "-rf", pkg_git_dir])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("clone_clean #{pkg.name}: OK")
    0
  }

  ## Main API - dependencies

  def build_dependencies = fn (pkg) {
    deps = Kpkg.resolve_dependencies(pkg, :build_depends_on)
    deps
  }

  def dependencies = fn (pkg) {
    deps = Kpkg.resolve_dependencies(pkg, :depends_on)
    deps
  }

  def install_build_dependencies = fn (pkg, tree) {
    Kpkg.log_call("install_build_dependencies #{pkg.name} #{tree}")
    Kpkg.indent(1)
    deps = Kpkg.build_dependencies(pkg)
    List.each(deps, fn ({dep_name, dep_tree}) {
      dep_pkg = Kpkg.get_package_or_die(dep_name)
      Kpkg.install(dep_pkg, dep_tree, Kpkg.arch_local())
    })
    Kpkg.indent(-1)
    Kpkg.log_call("install_build_dependencies #{pkg.name} #{tree}: OK")
  }

  def install_dependencies = fn (pkg, tree, arch) {
    Kpkg.log_call("install_dependencies #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    deps = Kpkg.dependencies(pkg)
    List.each(deps, fn ({dep_name, dep_tree}) {
      dep_pkg = Kpkg.get_package_or_die(dep_name)
      Kpkg.install(dep_pkg, dep_tree, arch)
    })
    Kpkg.indent(-1)
    Kpkg.log_call("install_dependencies #{pkg.name} #{tree} #{arch}: OK")
  }

  def resolve_dependencies = fn (pkg, sym) {
    # Kpkg.log_call("resolve_dependencies #{pkg.name} #{sym}")
    list = pkg[sym]
    pkg_tree_tuple_list = []
    while list != [] do
      [dep_name | rest] = ^ list
      match type(dep_name) do
        Tuple ->
          {dep_name, dep_tree} = ^ dep_name
          dep_pkg = Kpkg.get_package_or_die(dep_name)
        Sym ->
          dep_pkg = Kpkg.get_package_or_die(dep_name)
          dep_tree = dep_pkg.default_branch
        _ ->
          puts("kpkg: resolve_dependencies: invalid package: " +
            inspect(dep_name))
          exit(1)
      end
      dep_tuple = ^ {dep_name, dep_tree}
      if ! List.has?(pkg_tree_tuple_list, dep_tuple) do
        pkg_tree_tuple_list = [dep_tuple | pkg_tree_tuple_list]
      end
      list = List.append(rest, dep_pkg[sym])
    end
    # Kpkg.log_call("resolve_dependencies #{pkg.name} #{sym}: #{pkg_tree_tuple_list}")
    pkg_tree_tuple_list
  }

  ## Main API - build

  def build = fn (pkg, tree, arch) {
    Kpkg.log_call("build #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    Kpkg.configure(pkg, tree, arch)
    build_dir = Kpkg.build_dir(pkg, tree, arch)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.exists?("#{build_dir}/build.ninja") do
      Kpkg.exec!(["ninja", "-C", build_dir])
    else
      if File.exists?("#{build_dir}/Makefile") do
        Kpkg.exec!(["env", "srcdir=#{pkg_src_dir}",
                    pkg.make, "-C", build_dir])
      else
        puts("kpkg: build: no build method found in #{build_dir}")
        exit(1)
      end
    end
    Kpkg.indent(-1)
    Kpkg.log_call("build #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def configure = fn (pkg, tree, arch) {
    Kpkg.log_call("configure #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    Kpkg.install_build_dependencies(pkg, tree)
    Kpkg.checkout(pkg, tree)
    Kpkg.install_dependencies(pkg, tree, arch)
    build_dir = Kpkg.build_dir(pkg, tree, arch)
    build_dir_sh = Sh.escape(build_dir)
    File.ensure_directory(build_dir, Kpkg.umask)
    cc = Kpkg.cc(arch)
    cxx = Kpkg.cxx(arch)
    prefix = Kpkg.prefix_dir(arch)
    prefix_sh = Sh.escape(prefix)
    if ! File.access?("#{build_dir}/.kpkg_configure_done", :r) do
      configure = Kpkg.configure_path(pkg, tree)
      if (File.exists?(configure)) do
        configure_path_sh = Sh.escape(configure)
        make_sh = Sh.escape(pkg.make)
        if Kpkg.arch_local() == arch do
          Kpkg.exec!(["/bin/sh", "-c",
                      "cd #{build_dir_sh} &&" +
                      " MAKE=#{make_sh}" +
                      " #{configure_path_sh}" +
                      " --prefix #{prefix_sh} &&" +
                      " echo 1 > .kpkg_configure_done"])
        else
          arch_sh = Sh.escape(arch)
          pkg_config_libdir_sh = Sh.escape("#{prefix}/lib/pkgconfig")
          Kpkg.exec!(["/bin/sh", "-c",
                      "cd #{build_dir_sh} &&" +
                      " MAKE=#{make_sh}" +
                      " PKG_CONFIG_LIBDIR=#{pkg_config_libdir_sh}" +
                      " #{configure_path_sh}" +
                      " --host #{arch_sh} --target #{arch_sh}" +
                      " --prefix #{prefix_sh} &&" +
                      " echo 1 > .kpkg_configure_done"])
        end
      else
        cmakelists = Kpkg.cmake_path(pkg, tree)
        if File.exists?(cmakelists) do
          pkg_src_dir = Kpkg.src_dir(pkg, tree)
          pkg_src_dir_sh = Sh.escape(pkg_src_dir)
          if Kpkg.arch_local() == arch do
            Kpkg.exec!(["cmake", "-B", build_dir, "-S", pkg_src_dir,
                        "-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}",
                        "-DCMAKE_BUILD_TYPE=Release"])
          else
            if cc do
              if cxx do
                Kpkg.exec!(["cmake", "-B", build_dir, "-S", pkg_src_dir,
                            "-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}",
                            "-DCMAKE_BUILD_TYPE=Release",
                            "-DCMAKE_C_COMPILER=#{cc}",
                            "-DCMAKE_CXX_COMPILER=#{cxx}"])
              else
                Kpkg.exec!(["cmake", "-B", build_dir, "-S", pkg_src_dir,
                            "-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}",
                            "-DCMAKE_BUILD_TYPE=Release",
                            "-DCMAKE_C_COMPILER=#{cc}"])
              end
            else
              Kpkg.exec!(["cmake", "-B", build_dir, "-S", pkg_src_dir,
                          "-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}",
                          "-DCMAKE_BUILD_TYPE=Release"])
            end
          end
        else
          mesonbuild = Kpkg.meson_path(pkg, tree)
          if File.exists?(mesonbuild) do
            pkg_src_dir = Kpkg.src_dir(pkg, tree)
            if Kpkg.arch_local() == arch do
              Kpkg.exec!(["meson", "setup", build_dir, pkg_src_dir,
                          "--prefix=#{prefix}",
                          "--buildtype=release"])
            else
              cross_file = Kpkg.meson_cross_file_write(arch, cc, cxx)
              Kpkg.exec!(["meson", "setup", build_dir, pkg_src_dir,
                          "--prefix=#{prefix}",
                          "--buildtype=release",
                          "--cross-file=#{cross_file}" |
                         pkg.configure_options])
            end
          else
            puts("kpkg: configure: could not find a configure method")
            exit(1)
          end
        end
      end
    end
    Kpkg.indent(-1)
    Kpkg.log_call("configure #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def configure_clean = fn (pkg, tree, arch) {
    Kpkg.log_call("configure_clean #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    build_dir = Kpkg.build_dir(pkg, tree, arch)
    configure_done = "#{build_dir}/.kpkg_configure_done"
    if File.access?(configure_done, :r) do
      Kpkg.exec!(["rm", configure_done])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("configure_clean #{pkg.name} #{tree} #{arch}")
    0
  }

  ## Main API - package

  def fake = fn (pkg, tree, arch) {
    Kpkg.log_call("fake #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    Kpkg.build(pkg, tree, arch)
    build_dir = Kpkg.build_dir(pkg, tree, arch)
    build_dir_sh = Sh.escape(build_dir)
    destdir = Kpkg.destdir(pkg, tree, arch)
    destdir_sh = Sh.escape(destdir)
    File.ensure_directory(destdir, Kpkg.umask)
    cmake = Kpkg.cmake_path(pkg, tree)
    if File.exists?("#{build_dir}/build.ninja") do
      Kpkg.exec!(["env", "DESTDIR=#{destdir}",
                  "meson", "install", "-C", build_dir])
    else
      if File.exists?("#{build_dir}/CMakeLists.txt") do
        Kpkg.exec!(["sh", "-c", "cd #{build_dir_sh} &&" +
                    " cmake --build . --config Release --target install"])
      else
        Kpkg.exec!(["/bin/sh", "-c",
                    "#{pkg.make} -C #{Sh.escape(build_dir)}" +
                    " DESTDIR=#{destdir_sh} install"])
      end
    end
    Kpkg.indent(-1)
    Kpkg.log_call("fake #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def fake_clean = fn (pkg, tree, arch) {
    Kpkg.log_call("fake_clean #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    destdir = Kpkg.destdir(pkg, tree, arch)
    if File.exists?(destdir) do
      Kpkg.exec!(["rm", "-rf", destdir])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("fake_clean #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def package = fn (pkg, tree, arch) {
    Kpkg.log_call("package #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    pkg_path = Kpkg.package_path(pkg, tree, arch)
    pkg_name = "#{pkg.name}-#{tree}-#{arch}"
    pkg_pathname = "#{pkg_path}/#{pkg_name}"
    pkg_file = "#{pkg_pathname}.tar.gz"
    manifest_file = "#{pkg_pathname}.manifest"
    checksum_file = "#{pkg_pathname}.sha512"
    if ! File.exists?(pkg_file) ||
       ! File.exists?(manifest_file) ||
       ! File.exists?(checksum_file) do
      Kpkg.fake(pkg, tree, arch)
      destdir = Kpkg.destdir(pkg, tree, arch)
      prefix = Kpkg.prefix_dir(arch)
      destdir_prefix = "#{destdir}#{prefix}"
      File.ensure_directory(pkg_path, Kpkg.umask)
      files = File.list_recursive(destdir_prefix)
      manifest = str(List.map(files, fn (file_path) {
        if ! File.is_directory?(file_path) do
          checksum = File.sha512_base64url(file_path)
          rel_path = Str.slice(file_path, Str.size(destdir_prefix) + 1, -1)
          "#{checksum} #{rel_path}\n"
        end
      }))
      File.write_str(manifest_file, manifest)
      Kpkg.exec!(["tar", "-C", destdir_prefix, "-czf", pkg_file, "."])
      pkg_checksum = "#{File.sha512_base64url(pkg_file)} #{pkg_name}.tar.gz\n"
      File.write_str(checksum_file, pkg_checksum)
    end
    Kpkg.indent(-1)
    Kpkg.log_call("package #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def package_clean = fn (pkg, tree, arch) {
    Kpkg.log_call("package_clean #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    pkg_path = package_path(pkg, tree, arch)
    pkg_file = "#{pkg_path}/#{pkg.name}-#{tree}-#{arch}.tar.gz"
    manifest_file = "#{pkg_path}/#{pkg.name}-#{tree}-#{arch}.manifest"
    checksum_file = "#{pkg_path}/#{pkg.name}-#{tree}-#{arch}.sha512"
    if File.exists?(pkg_file) ||
       File.exists?(manifest_file) ||
       File.exists?(checksum_file) do
      Kpkg.exec!(["rm", "-f", pkg_file, manifest_file, checksum_file])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("package_clean #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  ## Main API - install

  def is_installed? = fn (pkg, tree, arch) {
    installed_path = Kpkg.installed_db_path(pkg, tree, arch)
    File.exists?(installed_path)
  }

  def install = fn (pkg, tree, arch) {
    Kpkg.log_call("install #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    is_needed? = pkg.is_needed?
    if is_needed?() &&
       ! Kpkg.is_installed?(pkg, tree, arch) do
      Kpkg.package(pkg, tree, arch)
      pkg_path = package_path(pkg, tree, arch)
      pkg_name = "#{pkg.name}-#{tree}-#{arch}"
      pkg_pathname = "#{pkg_path}/#{pkg_name}"
      pkg_file = "#{pkg_pathname}.tar.gz"
      manifest_file = "#{pkg_pathname}.manifest"
      prefix = Kpkg.prefix_dir(arch)
      installed_path = Kpkg.installed_db_path(pkg, tree, arch)
      installed_dir = File.dirname(installed_path)
      tmp_dir = Kpkg.tmp(prefix)
      File.ensure_directory(prefix, Kpkg.umask)
      File.ensure_directory(installed_dir, Kpkg.umask)
      File.ensure_directory(tmp_dir, Kpkg.umask)
      Kpkg.exec!(["tar", "-C", tmp_dir, "-xzf", pkg_file])
      tmp_files = File.list_recursive(tmp_dir)
      List.each(tmp_files, fn (file) {
        if ! File.is_directory?(file) do
          src = Str.slice(file, Str.size(tmp_dir), -1)
          target = "#{prefix}#{src}"
          if File.exists?(target) do
            puts("install: file exists, not copying: #{target}")
            exit(1)
          else
            target_dir = File.dirname(target)
            File.ensure_directory(target_dir, Kpkg.umask)
            Kpkg.exec!(["rsync", "-a", file, "#{target_dir}/"])
          end
        end
      })
      Kpkg.exec!(["rm", "-rf", tmp_dir])
      Kpkg.exec!(["cp", manifest_file, installed_path])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("install #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  def uninstall = fn (pkg, tree, arch) {
    Kpkg.log_call("uninstall #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    if Kpkg.is_installed?(pkg, tree, arch) do
      prefix = Kpkg.prefix_dir(arch)
      pkg_path = package_path(pkg, tree, arch)
      pkg_name = "#{pkg.name}-#{tree}-#{arch}"
      pkg_pathname = "#{pkg_path}/#{pkg_name}"
      installed_path = Kpkg.installed_db_path(pkg, tree, arch)
      installed = File.read_all(installed_path)
      List.each(Str.split(installed, "\n"), fn (line) {
        if (line != "") do
          pos = Str.position_str(line, " ")
          hash = Str.slice(line, 0, pos)
          filename = "#{prefix}/#{Str.slice(line, pos + 1, -1)}"
          if File.exists?(filename) do
            if File.is_regular?(filename) do
              if File.sha512_base64url(filename) == hash do
                Kpkg.exec!(["rm", "-f", filename])
              else
                puts("kpkg: uninstall: checksum changed: #{filename}")
              end
            else
              Kpkg.exec!(["rm", "-f", filename])
            end
          else
            puts("kpkg: uninstall: missing file: #{filename}")
          end
        end
      })
      Kpkg.exec!(["rm", "-f", installed_path])
    end
    Kpkg.indent(-1)
    Kpkg.log_call("uninstall #{pkg.name} #{tree} #{arch}: OK")
    0
  }

  ## Main API - misc

  def clean_pkg = fn (pkg) {
    Kpkg.log_call("clean_pkg #{pkg.name}")
    Kpkg.indent(1)
    Kpkg.exec!(["rm", "-rf", Kpkg.git_dir(pkg)])
    Kpkg.exec!(["rm", "-rf", "#{Kpkg.dir()}/src/#{pkg.dir}"])
    dir_sh = "#{Sh.escape(Kpkg.dir())}/arch/*/*/#{Sh.escape(pkg.dir)}"
    Kpkg.exec!(["sh", "-c", "rm -rf #{dir_sh}"])
    Kpkg.indent(-1)
    Kpkg.log_call("clean_pkg #{pkg.name}: OK")
    0
  }

  def clean_pkg_tree = fn (pkg, tree) {
    Kpkg.log_call("clean_pkg_tree #{pkg.name} #{tree}")
    Kpkg.indent(1)
    Kpkg.exec!(["rm", "-rf", Kpkg.src_dir(pkg, tree)])
    dir_sh_1 = Sh.escape("#{Kpkg.dir()}/arch")
    dir_sh_2 = Sh.escape("#{pkg.dir}/#{tree}")
    dir_sh = "#{dir_sh_1}/*/*/#{dir_sh_2}"
    Kpkg.exec!(["sh", "-c", "rm -rf #{dir_sh}"])
    Kpkg.indent(-1)
    Kpkg.log_call("clean_pkg_tree #{pkg.name} #{tree}: OK")
    0
  }

  def clean_pkg_tree_arch = fn (pkg, tree, arch) {
    Kpkg.log_call("clean_pkg_tree_arch #{pkg.name} #{tree} #{arch}")
    Kpkg.indent(1)
    arch_sh = Sh.escape(arch)
    kpkg_dir_sh = Sh.escape(Kpkg.dir())
    pkg_dir_sh = Sh.escape("#{pkg.dir}/#{tree}")
    dir_sh = " #{kpkg_dir_sh}/arch/#{arch_sh}/*/#{pkg_dir_sh}"
    Kpkg.exec!(["sh", "-c", "rm -rf #{dir_sh}"])
    Kpkg.indent(-1)
    Kpkg.log_call("clean_pkg #{pkg.name}: OK")
    0
  }

  def info = fn (pkg, tree, arch) {
    Kpkg.log_call("info #{pkg.name} #{tree} #{arch}")
    arch_local = Kpkg.arch_local()
    local_or_empty = if arch == arch_local do
      " (local)"
    else
      ""
    end
    style? = Kpkg.style?()
    reset = if style? do "#{Terminal.reset}" end
    title = if style? do "#{Terminal.bold}#{Terminal.fg_blue}" end
    puts("#{title}pkg:#{reset}")
    puts("#{pkg}")
    puts("#{title}tree:#{reset} #{inspect(tree)}")
    puts("#{title}arch:#{reset}       #{inspect(arch)}#{local_or_empty}")
    puts("#{title}arch_local:#{reset} #{inspect(arch_local)}")
    puts("#{title}build_dependencies:#{reset} #{Kpkg.build_dependencies(pkg)}")
    puts("#{title}cc:#{reset}       #{inspect(Kpkg.cc(arch))}")
    puts("#{title}cc_local:#{reset} #{inspect(Kpkg.cc_local())}")
    puts("#{title}dependencies:#{reset}")
    puts(Kpkg.dependencies(pkg))
    puts("#{title}uname:#{reset} #{inspect(Kpkg.uname())}")
    0
  }

end
