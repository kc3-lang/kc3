## kc3
## Copyright from 2022 to 2025 kmx.io <contact@kmx.io>
##
## Permission is hereby granted to use this software granted the above
## copyright notice and this permission paragraph are included in all
## copies and substantial portions of this software.
##
## THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
## PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
## AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
## THIS SOFTWARE.

require File
require IO
require Kpkg.Package
require Sh

# Kpkg

defmodule Kpkg do

  ## Configuration

  def dir = fn () {
    dir = if from_env = getenv("KPKG_DIR") do
      from_env
    else
      if home = getenv("HOME") do
        "#{home}/kpkg/"
      end
    end
    if Str.ends_with?(dir, "/") do
      Str.slice(dir, 0, -2)
    else
      dir
    end
  }

  def db = Facts.database()

  ## Package definition

  def defpackage = fn (package) {
    Facts.add_tags(Kpkg.db, package.name, :is_a, Kpkg.Package)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_depends_on, package.depends_on)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_dir, package.dir)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git, package.git)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git_push, package.git_push)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_module, package.module)
  }

  def defalias = fn (name, target) {
    Facts.add_tags(db, name, :is_a, Kpkg.Package.Alias)
    Facts.add_tags(db, name, :kpkg_package_alias_target, target)
  }

  ## Package API

  def get_kpkg_package = fn (name) {
    Facts.first_with(db, [[name, :is_a, Kpkg.Package],
                          [name, :kpkg_package_dir, dir = ?],
                          [name, :kpkg_package_git, git = ?],
                          [name, :kpkg_package_git_push, git_push = ?],
                          [name, :kpkg_package_module, module = ?]],
      fn (fact) { %Kpkg.Package{name: name, dir: dir, git: git,
                                git_push: git_push, module: module} })
  }
  
  def get_kpkg_package_alias = fn (name) {
    if name = Sym.find(name) do
      while (new_name = Facts.first_with_tags(db, name,
               :kpkg_package_alias_target, new_name = ?,
               fn (fact) { new_name })) do
        name = new_name
      end
      name
    end
  }
        
  def get_package = fn (name) {
    if name = get_kpkg_package_alias(name) do
      get_kpkg_package(name)
    end
  }

  ## Main entry point

  def main = fn {
    ([]) {
      Kpkg.usage()
      0
    }
    ([name | rest]) {
       Kpkg.load()
       if pkg = Kpkg.get_package(name) do
         main_args(pkg, rest)
       else
         puts("kpkg: package not found: #{name}")
         1
       end
     }
  }
  def load = fn () {
    File.ensure_directory(dir(), 0o755)
    Kpkg.Package.load_all()
  }

  ## Argument parsing

  def main_args = fn {
    (pkg, []) { puts(pkg) }
    (pkg, args) { Kpkg.main_args(pkg, pkg.default_branch, "", args, 0) }
    (pkg, tree, arch, ["--arch", arch_arg | rest], 0) {
      Kpkg.main_args(pkg, tree, arch_arg, rest, 0)
    }
    (pkg, tree, arch, ["checkout" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.checkout(pkg, tree))
    }
    (pkg, tree, arch, ["checkout-clean" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.checkout_clean(pkg, tree))
    }
    (pkg, tree, arch, ["clone" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.clone(pkg))
    }
    (pkg, tree, arch, ["clone-clean" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.clone_clean(pkg))
    }
    (pkg, tree, arch, ["info" | rest], 0) {
      puts(pkg)
      Kpkg.main_args(pkg, tree, arch, rest, 0)
    }
    (pkg, tree, arch, ["--tree", tree_arg | rest], 0) {
      Kpkg.main_args(pkg, tree_arg, arch, rest, 0)
    }
    (pkg, tree, arch, [], 0) { 0 }
    (pkg, tree, arch, args, 0) {
      puts("kpkg: unknown argument: #{args}")
      1
    }
    (pkg, tree, arch, args, ret) { ret }
  }

  def usage = fn () {
    puts("""
Usage: KPKG_DIR=~/kpkg kpkg PKG [OPTIONS] COMMAND [ARG ...] ...
 Options :
  --tree TREE           work on $TREE
 Source directory commands :
  checkout              git checkout $TREE into src/$DIR/$TREE
  checkout-clean        remove checkout files :  src/$DIR/$TREE
  clone                 git clone into git/$DIR
  clone-clean           remove git repo files: git/$DIR
  clean-sources         clean src/$DIR and git/$DIR
 Build commands :
  configure
  clean-configure       remove configure-done tag
  build                 run parallel build
  clean-build           remove object files
""")
  }

  ## Package configuration

  def git_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{pkg.dir}"
  }

  def git_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{File.dirname(pkg.dir)}"
  }

  def src_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/src/#{pkg.dir}"
  }

  ## Tree configuration

  def src_dir = fn (pkg, tree) {
    "#{Kpkg.dir()}/src/#{pkg.dir}/#{tree}"
  }

  ## Arch configuration

  def arch_dir = fn (pkg, tree, arch) {
    "#{Kpkg.dir()}/arch/#{arch}/src/#{pkg.dir}/#{tree}"
  }

  ## Internal API

  def exec = fn (cmd) {
    puts(List.join(cmd, " "))
    result = system(cmd)
    if (result && result != "") do
      if (Str.ends_with?(result, "\n")) do
        IO.write_str(result)
      else
        IO.puts(result)
      end
    end
  }

  ## Main API - sources from git

  def autogen = fn (pkg, tree) {
    Kpkg.checkout(pkg, tree)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.exists?(pkg_src_dir + "/autogen.sh") do
      Kpkg.exec(["/bin/sh", "-c", "cd #{Sh.escape(pkg_src_dir)} && /bin/sh autogen.sh"])
    else
      if File.exists?(pkg_src_dir + "/autogen") do
        Kpkg.exec(["/bin/sh", "-c", "cd #{Sh.escape(pkg_src_dir)} && /bin/sh autogen"])
      end
    end
  }

  def checkout = fn (pkg, tree) {
    Kpkg.clone(pkg)
    pkg_git_dir = Kpkg.git_dir(pkg) + "/.git"
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if ! File.is_directory?(pkg_src_dir) do
      Kpkg.exec(["mkdir", "-p", Kpkg.src_parent_dir(pkg)])
      Kpkg.exec(["git", "clone", "-b", tree, pkg_git_dir, pkg_src_dir])
      Kpkg.exec(["git", "-C", pkg_src_dir, "submodule", "init"])
      Kpkg.exec(["git", "-C", pkg_src_dir, "submodule", "update",
                 "--recursive", "--remote"])
      Kpkg.autogen(pkg, tree)
    end
    0
  }

  def checkout_clean = fn (pkg, tree) {
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.is_directory?(pkg_src_dir) do
      Kpkg.exec(["rm", "-rf", pkg_src_dir])
    end
    0
  }

  def clone = fn (pkg) {
    pkg_git_dir = Kpkg.git_dir(pkg)
    if ! File.is_directory?(pkg_git_dir) do
      Kpkg.exec(["mkdir", "-p", Kpkg.git_parent_dir(pkg)])
      Kpkg.exec(["git", "clone", pkg.git, pkg_git_dir])
      Kpkg.exec(["git", "-C", pkg_git_dir, "submodule", "init"])
      Kpkg.exec(["git", "-C", pkg_git_dir, "submodule", "update",
                 "--recursive", "--remote"])
    end
    0
  }

  def clone_clean = fn (pkg) {
    pkg_git_dir = Kpkg.git_dir(pkg)
    if File.is_directory?(pkg_git_dir) do
      Kpkg.exec(["rm", "-rf", pkg_git_dir])
    end
    0
  }

  ## Main API - dependencies

  def install_dependencies = fn (pkg, tree, arch) {
    List.each(pkg.depends_on, fn (dep_name) {
      if type(dep_name) == Tuple do
        {dep_name, dep_tree} = ^ dep_name
        dep_pkg = Kpkg.get_package(dep_name)
      else
        dep_pkg = Kpkg.get_package(dep_name)
        dep_tree = dep_pkg.default_branch
      end
      Kpkg.install(dep_pkg, dep_tree, arch)
    })
  }

  ## Main API - build

  def configure = fn (pkg, tree, arch) {
    Kpkg.install_dependencies(pkg, tree, arch)
  }

  ## Main API - misc

  def info = fn (pkg, tree) {
    puts("#{pkg}")
    puts("tree: #{tree}")
  }

end
