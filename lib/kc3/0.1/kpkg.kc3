## kc3
## Copyright from 2022 to 2025 kmx.io <contact@kmx.io>
##
## Permission is hereby granted to use this software granted the above
## copyright notice and this permission paragraph are included in all
## copies and substantial portions of this software.
##
## THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
## PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
## AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
## THIS SOFTWARE.

require FD
require File
require IO
require Kpkg.Package
require Sh
require Terminal

# Kpkg

defmodule Kpkg do

  ## Configuration

  def cc_local = fn () {
    pathname = File.which(getenv("CC_LOCAL")) ||
      File.which("cc") || File.which("clang") ||
      File.which("gcc")
    if File.access?(pathname, :x) do
      pathname
    else
      puts("Please set CC_LOCAL to a valid local C compiler")
      exit(1)
    end
  }

  def cc = fn {
    () {
      cc_local()
    }
    (arch) {
      if arch == Kpkg.arch_local() do
        return cc_local()
      else
        pathname = File.which(getenv("CC"))
        if File.access?(pathname, :x) do
          pathname
        else
          puts("Please set CC to a valid target C compiler")
          exit(1)
        end
      end
    }
  }

  def dir = fn () {
    dir = if from_env = getenv("KPKG_DIR") do
      from_env
    else
      if home = getenv("HOME") do
        "#{home}/kpkg/"
      end
    end
    if Str.ends_with?(dir, "/") do
      Str.slice(dir, 0, -2)
    else
      dir
    end
  }

  def db = Facts.database()

  def uname = fn () {
    Str.slice(system(["uname"]), 0, -2);
  }

  ## Package definition

  def defpackage = fn (package) {
    Facts.add_tags(Kpkg.db, package.name, :is_a, Kpkg.Package)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_build_depends_on, package.build_depends_on)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_depends_on, package.depends_on)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_dir, package.dir)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git, package.git)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_git_push, package.git_push)
    Facts.replace_tags(Kpkg.db, package.name,
      :kpkg_package_module, package.module)
  }

  def defalias = fn (name, target) {
    Facts.add_tags(db, name, :is_a, Kpkg.Package.Alias)
    Facts.add_tags(db, name, :kpkg_package_alias_target, target)
  }

  ## Package API

  def get_kpkg_package = fn (name) {
    Facts.first_with(db, [[name, :is_a, Kpkg.Package],
                          [name, :kpkg_package_build_depends_on,
                           build_depends_on = ?],
                          [name, :kpkg_package_depends_on,
                           depends_on = ?],
                          [name, :kpkg_package_dir, dir = ?],
                          [name, :kpkg_package_git, git = ?],
                          [name, :kpkg_package_git_push, git_push = ?],
                          [name, :kpkg_package_module, module = ?]],
      fn (fact) { %Kpkg.Package{name: name,
                                build_depends_on: build_depends_on,
                                depends_on: depends_on,
                                dir: dir,
                                git: git,
                                git_push: git_push,
                                module: module} })
  }
  
  def get_kpkg_package_alias = fn (name) {
    if name = Sym.find(name) do
      while (new_name = Facts.first_with_tags(db, name,
               :kpkg_package_alias_target, new_name = ?,
               fn (fact) { new_name })) do
        name = new_name
      end
      name
    end
  }

  def get_package = fn (name) {
    if name = get_kpkg_package_alias(name) do
      get_kpkg_package(name)
    end
  }

  def get_package_or_die = fn (name) {
    if ! (pkg = Kpkg.get_package(name)) do
      puts("kpkg: package not found: #{name}")
      exit(1)
    end
    pkg
  }

  ## Main entry point

  def main = fn {
    ([]) {
      Kpkg.usage()
      0
    }
    ([name | rest]) {
       Kpkg.load()
       pkg = Kpkg.get_package_or_die(name)
       main_args(pkg, rest)
     }
  }

  def load = fn () {
    File.ensure_directory(dir(), 0o755)
    Kpkg.Package.load_all()
  }

  ## Argument parsing

  def main_args = fn {
    (pkg, []) { puts(pkg) }
    (pkg, args) {
      Kpkg.main_args(pkg, pkg.default_branch, arch_local(), args, 0)
    }
    (pkg, tree, arch, ["--arch", arch_arg | rest], 0) {
      Kpkg.main_args(pkg, tree, arch_arg, rest, 0)
    }
    (pkg, tree, arch, ["checkout" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.checkout(pkg, tree))
    }
    (pkg, tree, arch, ["checkout-clean" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.checkout_clean(pkg, tree))
    }
    (pkg, tree, arch, ["clone" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.clone(pkg))
    }
    (pkg, tree, arch, ["clone-clean" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.clone_clean(pkg))
    }
    (pkg, tree, arch, ["info" | rest], 0) {
      Kpkg.main_args(pkg, tree, arch, rest,
        Kpkg.info(pkg, tree, arch))
    }
    (pkg, tree, arch, ["--tree", tree_arg | rest], 0) {
      Kpkg.main_args(pkg, tree_arg, arch, rest, 0)
    }
    (pkg, tree, arch, [], 0) { 0 }
    (pkg, tree, arch, args, 0) {
      puts("kpkg: unknown argument: #{args}")
      1
    }
    (pkg, tree, arch, args, ret) { ret }
  }

  def usage = fn () {
    reset = ^ Terminal.reset
    bold = ^ Terminal.bold
    underline = ^ Terminal.underline
    puts("""
Usage: KPKG_DIR=~/kpkg #{bold}kpkg#{reset} PKG [OPTIONS] COMMAND [ARG ...] ...
  #{underline}Options :#{reset}
    --arch ARCH          build for $ARCH
    --tree TREE          work on $TREE
  #{underline}Source directory commands :#{reset}
    checkout             git checkout $TREE into src/$DIR/$TREE
    checkout-clean       remove checkout files :  src/$DIR/$TREE
    clone                git clone into git/$DIR
    clone-clean          remove git repo files: git/$DIR
    clean-sources        clean src/$DIR and git/$DIR
  #{underline}Dependencies commands :#{reset}
    build-dependencies   show build-time dependencies
    dependencies         show dependencies
    install-build-deps   install build-time dependencies into arch/$ARCH/
    install-deps
  #{underline}Build commands :#{reset}
    configure            run configure in arch/$ARCH/obj/$DIR/$TREE
    clean-configure      remove configure-done tag
    build                run parallel build
    clean-build          remove object files
  #{underline}Misc commands :#{reset}
    info                 show current state
""")
  }

  ## Package configuration

  def git_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{pkg.dir}"
  }

  def git_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/git/#{File.dirname(pkg.dir)}"
  }

  def src_parent_dir = fn (pkg) {
    "#{Kpkg.dir()}/src/#{pkg.dir}"
  }

  ## Tree configuration

  def src_dir = fn (pkg, tree) {
    "#{Kpkg.dir()}/src/#{pkg.dir}/#{tree}"
  }

  ## Arch configuration

  def arch_dir = fn (pkg, tree, arch) {
    "#{Kpkg.dir()}/arch/#{arch}/src/#{pkg.dir}/#{tree}"
  }

  def arch_local = fn () {
    List.each(Str.split(system([Kpkg.cc_local(), "-v"]), "\n"),
      fn (line) {
        if Str.starts_with?(line, "Target: ") do
          return_from :arch_local Str.slice(line, 8, -1)
        end
      })
  }

  ## Internal API

  def exec = fn (cmd) {
    puts(List.join(cmd, " "))
    result = system(cmd)
    if (result && result != "") do
      if (Str.ends_with?(result, "\n")) do
        IO.write_str(result)
      else
        IO.puts(result)
      end
    end
  }

  ## Main API - sources from git

  def autogen = fn (pkg, tree) {
    Kpkg.checkout(pkg, tree)
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.exists?(pkg_src_dir + "/autogen.sh") do
      Kpkg.exec(["/bin/sh", "-c", "cd #{Sh.escape(pkg_src_dir)} && /bin/sh autogen.sh"])
    else
      if File.exists?(pkg_src_dir + "/autogen") do
        Kpkg.exec(["/bin/sh", "-c", "cd #{Sh.escape(pkg_src_dir)} && /bin/sh autogen"])
      end
    end
  }

  def checkout = fn (pkg, tree) {
    Kpkg.clone(pkg)
    pkg_git_dir = Kpkg.git_dir(pkg) + "/.git"
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if ! File.is_directory?(pkg_src_dir) do
      Kpkg.exec(["mkdir", "-p", Kpkg.src_parent_dir(pkg)])
      Kpkg.exec(["git", "clone", "-b", tree, pkg_git_dir, pkg_src_dir])
      Kpkg.exec(["git", "-C", pkg_src_dir, "submodule", "init"])
      Kpkg.exec(["git", "-C", pkg_src_dir, "submodule", "update",
                 "--recursive", "--remote"])
      Kpkg.autogen(pkg, tree)
    end
    0
  }

  def checkout_clean = fn (pkg, tree) {
    pkg_src_dir = Kpkg.src_dir(pkg, tree)
    if File.is_directory?(pkg_src_dir) do
      Kpkg.exec(["rm", "-rf", pkg_src_dir])
    end
    0
  }

  def clone = fn (pkg) {
    pkg_git_dir = Kpkg.git_dir(pkg)
    if ! File.is_directory?(pkg_git_dir) do
      Kpkg.exec(["mkdir", "-p", Kpkg.git_parent_dir(pkg)])
      Kpkg.exec(["git", "clone", pkg.git, pkg_git_dir])
      Kpkg.exec(["git", "-C", pkg_git_dir, "submodule", "init"])
      Kpkg.exec(["git", "-C", pkg_git_dir, "submodule", "update",
                 "--recursive", "--remote"])
    end
    0
  }

  def clone_clean = fn (pkg) {
    pkg_git_dir = Kpkg.git_dir(pkg)
    if File.is_directory?(pkg_git_dir) do
      Kpkg.exec(["rm", "-rf", pkg_git_dir])
    end
    0
  }

  ## Main API - dependencies

  def build_dependencies = fn (pkg) {
    Kpkg.resolve_dependencies(pkg.build_depends_on,
      Kpkg.build_dependencies)
  }

  def dependencies = fn (pkg) {
    Kpkg.resolve_dependencies(pkg.depends_on,
      Kpkg.dependencies)
  }

  def resolve_dependencies = fn (list, dependencies_callable) {
    # puts("resolve_dependencies: list: #{inspect(list)}")
    pkg_tree_tuple_list = []
    while list != [] do
      [dep_name | rest] = ^ list
      # puts("resolve_dependencies: dep_name: #{inspect(dep_name)}")
      if type(dep_name) == Tuple do
        {dep_name, dep_tree} = ^ dep_name
        dep_pkg = Kpkg.get_package_or_die(dep_name)
      else
        if type(dep_name) == Sym do
          dep_pkg = Kpkg.get_package_or_die(dep_name)
          dep_tree = dep_pkg.default_branch
        else
          puts("kpkg: resolve_dependencies: invalid package: " +
            inspect(dep_name))
          exit(1)
        end
      end
      dep_tuple = {dep_name, dep_tree}
      if ! List.has?(pkg_tree_tuple_list, dep_tuple) do
        pkg_tree_tuple_list = [dep_tuple | pkg_tree_tuple_list]
      end
      list = List.append(rest, dependencies_callable(dep_pkg))
    end
    pkg_tree_tuple_list
  }

  def install_build_dependencies = fn (pkg, tree) {
    deps = Kpkg.build_dependencies(pkg)
    List.each(deps, fn ({dep_pkg, dep_tree}) {
      Kpkg.install(dep_pkg, dep_tree, Kpkg.local_arch)
    })
  }

  def install_dependencies = fn (pkg, tree, arch) {
    deps = Kpkg.dependencies(pkg)
    List.each(deps, fn ({dep_pkg, dep_tree}) {
      Kpkg.install(dep_pkg, dep_tree, arch)
    })
  }

  ## Main API - build

  def configure = fn (pkg, tree, arch) {
    Kpkg.install_build_dependencies(pkg, tree)
    Kpkg.install_dependencies(pkg, tree, arch)
  }

  ## Main API - misc

  def info = fn (pkg, tree, arch) {
    arch_local = Kpkg.arch_local()
    local_or_empty = if arch == arch_local do
      " (local)"
    else
      ""
    end
    reset = if FD.is_a_tty?(1) do "#{Terminal.reset}" end
    title = if FD.is_a_tty?(1) do "#{Terminal.bold}#{Terminal.fg_blue}" end
    puts("#{title}pkg:#{reset}")
    puts("#{pkg}")
    puts("#{title}tree:#{reset} #{inspect(tree)}")
    puts("#{title}arch:#{reset}       #{inspect(arch)}#{local_or_empty}")
    puts("#{title}arch_local:#{reset} #{inspect(arch_local)}")
    puts("#{title}build_dependencies:#{reset} #{Kpkg.build_dependencies(pkg)}")
    puts("#{title}cc:#{reset}       #{inspect(Kpkg.cc(arch))}")
    puts("#{title}cc_local:#{reset} #{inspect(Kpkg.cc_local())}")
    puts("#{title}dependencies:#{reset}")
    puts(Kpkg.dependencies(pkg))
    puts("#{title}uname:#{reset} #{inspect(Kpkg.uname())}")
  }

end
