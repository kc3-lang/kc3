# Tutoriel KC3 et exemples

Voici quelques exemples `ikc3` avec lesquels vous pouvez vous exercer.

## Maps

Les maps KC3 sont des structures clÃ©-valeur. Vous pouvez utiliser
nâ€™importe quel `Tag` comme clÃ© et lui associer une valeur.

Vous pouvez utiliser la dÃ©structuration pour accÃ©der aux maps KC3 :
```elixir
ikc3> a = %{id: 1, title: "My title", message: "Hello, world !"}
%{id: 1, title: "My title", message: "Hello, world !"}
ikc3> a = %{}
%{id: 1, title: "My title", message: "Hello, world !"}
ikc3> %{id: id, title: "My title", message: message} = a
%{id: 1, title: "My title", message: "Hello, world !"}
ikc3> id
1
ikc3> message
"Hello, world !"
```

Vous pouvez utiliser la syntaxe par point pour accÃ©der aux valeurs
d'une clÃ© `Sym` :
```elixir
ikc3> a = %{id: 1, title: "My title", message: "Hello, world !"}
%{id: 1, title: "My title", message: "Hello, world !"}
ikc3> a.id
1
ikc3> a.message
"Hello, world !"
```

Vous pouvez Ã©galement utiliser la fonction `KC3.access` pour obtenir
le mÃªme rÃ©sultat :
```elixir
ikc3> a = %{id: 1, title: "My title", message: "Hello, world !"}
%{id: 1, title: "My title", message: "Hello, world !"}
ikc3> access(a, :id)
1
ikc3> access(a, :message)
"Hello, world !"
```

## Unicode characters

`ikc3` prend entiÃ¨rement en charge Unicode :

Quelques caractÃ¨res Unicode :
```elixir
ikc3> '\U+1B2FB'
'ð›‹»'
ikc3> 'ð…€'
'ð…€'
ikc3> 'ðŸ¤©'
'ðŸ¤©'
ikc3>
```

## Grands entiers

```elixir
ikc3> a = 1 + 100000000000000000000000000000000
100000000000000000000000000000001
ikc3> a * a
10000000000000000000000000000000200000000000000000000000000000001
ikc3>
```

## Ratios

Les ratios sont crÃ©Ã©s avec un couple d'entiers : le numÃ©rateur
qui peut Ãªtre n'importe quel entier, et le dÃ©nominateur qui doit Ãªtre positif.
Ils reprÃ©sentent des fractions de nombres entiers.
Ils sâ€™Ã©crivent avec un slash sans espace.

```elixir
ikc3> 1/2 + 2/3
7/6
ikc3> 1/2 * 2/3
1/3
ikc3> 1/2 / 2/3
3/4
ikc3> 1/2 - 2/3
-1/6
```

## Nombres complexes

Les nombres complexes sont construits Ã  lâ€™aide de lâ€™opÃ©rateur `+i` sur tout
type de nombre (entiers signÃ©s, non signÃ©s, flottants, ratios, ou mÃªme
d'autres nombres complexes). Par exemple vous pouvez ecrire `a +i b`
oÃ¹ `a` et `b` sont des nombre flottants.

```elixir
ikc3> 1 +i 2
1 +i 2
ikc3> 1 +i 2 + 2 +i 3
3 +i 5
ikc3> (1 +i 2) * (2 +i 3)
-4 +i 7
ikc3> (1 +i 2) / (2 +i 3)
0 +i 0
ikc3> (1/1 +i 2/1) / (2 +i 3)
8/13 +i 1/13
```

Comme vous pouvez voir la division entiere ne produit pas de fractions.
Cela pourrait changer dans les versions futures.

## Lists

Les listes s'Ã©crivent avec des crochets : `[]`.

Les listes rÃ©guliÃ¨res peuvent Ãªtre :
 - un Ã©lÃ©ment et une liste : `[1 | []]` â†’ `[1]`
 - plusieurs Ã©lÃ©ments : `[1, 2, 3]`
 - plusieurs Ã©lÃ©ments et une liste : `[1, 2 | [3, 4]]` â†’ `[1, 2, 3, 4]`
 - la liste vide : `[]`

Les listes rÃ©guliÃ¨res se terminent toutes par la liste vide :
`[1] == [1 | []]`.

On peut Ã©galement contruire des listes pointÃ©es comme en Common Lisp
oÃ¹ le pointeur de liste suivante est une valeur arbitraire (`Tag`).
Par exemple :
 - un Ã©lÃ©ment et un Ã©lÃ©ment : `[1 | 2]`
 - plusieurs Ã©lÃ©ments et un Ã©lÃ©ment : `[1, 2, 3 | 4]`
 - la liste vide et un Ã©lÃ©ment : `[[] | 1]`

Tous ces formats de listes sont supportÃ©s dans la dÃ©structuration.

## L'identification de motifs et la dÃ©structuration

Les principes de *pattern-matching* viennent d'Erlang et Elixir.

Toutes les structures de donnÃ©es taggÃ©es de KC3 peuvent Ãªtre identifiÃ©es
(match) par un motif (pattern) en utilisant le signe Ã©gal (`=`) sur des
valeurs littÃ©rales contenant des identifiants. Tous les identifiants sont
repÃ©rÃ©s comme des nouvelles variables qui seront liÃ©es Ã  une valeur lors
de la dÃ©structuration. Si vous voulez utiliser une variable c'est possible
dans un appel de fonction ou en utilisant l'operateur identitÃ© :
`^ ma_variable`. Les variables peuvent se trouver de chaque cotÃ© du signe
Ã©gal tant qu'une vraie valeur se trouve dans la mÃªme structure de l'autre
cÃ´tÃ© de l'operateur Ã©gal.

Exemples :
```elixir
ikc3> a = 1
1
ikc3> a = 2
2
ikc3> a
2
ikc3> ^ a = 1
void
ikc3> ^ a = 2
2
ikc3> ^ a = b
2
ikc3> b
2
```

Pour utiliser la dÃ©structuration il suffit de taper la valeur littÃ©rale
que l'on veut identifier et de mettre des identifiants sur les parties
inconnues que l'on veut rÃ©cupÃ©rer de l'autre cotÃ© du signe Ã©gal. C'est
l'approche la plus visuelle possible pour programmer une identification
de valeurs, bien plus simple que SQL ou SPARQL. Les donnÃ©es sont
constamment affichÃ©es dans le code en affichant les variables dans la
structure d'origine. On voit les donnÃ©es et leur type Ã  l'Ã©cran
constamment. Cela aide vraiement pour Ã©crire de gros programmes qui ont
besoin de grandir en terme d'abstractions : laisser les donnÃ©es passer
dans le code Ã  travers des types visuels.

Exemples :
```elixir
ikc3> [x, y | z] = List.reverse([1, 2, 3, 4])
[4, 3, 2, 1]
ikc3> x
4
ikc3> y
3
ikc3> z
[2, 1]
```

## Macros

Les macros KC3 sont comme les macros Common Lisp avec le *pattern-matching*
 (dÃ©structuration) d'Elixir.

Les macros sont comme des fonctions mais sont introduites par `macro`
au lieu de `fn` et leurs arguments ne sont pas Ã©valuÃ©s. Par contre ils
sont dÃ©structurÃ©s avec toute la puissance du *pattern-matcher* pour
extraire des variabes des arguments passÃ©s Ã  la fonction. On peut
utiliser un `Map` pour avoir des arguments nommÃ©s, une liste pour avoir
des arguments `&rest`, ou un bloc pour avoir un argument `&body`.

Une fois Ã©valuÃ©e un appel de macro retourne un `Tag` (une valeur) qui est
Ã  son tour Ã©valuÃ©e dans l'environnement lexical de l'appel. Cela permet
la crÃ©ation de DSL (*domain-specific languages*) en KC3.

Plusieurs opÃ©rations basiques sont dÃ©finies comme des macros en KC3 :
la gestion des erreurs, les segment de code de *clean-up* avec
`unwind_protect`, les opÃ©rations sur la base de donnÃ©es en graphe.

## If, then, else.

Les conditions en KC3 fonctionnent comme en Ruby, par exemple :
```elixir
ikc3> if true && true
ikc3>   1 + 1
ikc3>   2 + 2
ikc3> end
4

ikc3> if true && false
ikc3>   1 + 1
ikc3>   2 + 2
ikc3> else
ikc3>   3 + 3
ikc3>   4 + 4
ikc3> end
8
```

Un `if` renvoie toujours une valeur. Si la condition est vraie une fois
castÃ©e en `Bool` avec `Bool.cast` (`bool_init_cast`), le premier bloc est
Ã©valuÃ© et retournÃ©. Si la condition donne `false` (faux) alors le second
bloc est Ã©valuÃ© (`else`). Si la condition est fausse et qu'il n'y a pas
de second bloc, `void` est retournÃ©.

Exemples sur une seule ligne avec `then` :
```elixir
ikc3> if 42 then 100 else 101 end
100
ikc3> if 0 then 100 else 101 end
101
```

## defmodule et def

Exemple :
```elixir
ikc3> defmodule Example do
ikc3>   def three = 3
ikc3>   def double = fn (x) do x * 2 end
ikc3>   def double_tuple = macro (x) do {x, x} end
ikc3>   def operator_double = %KC3.Operator{sym: :double, symbol_value: fn (x) { x * 2 }
ikc3> end
Example
ikc3> Example.three
3
ikc3> Example.double
fn (x) do x * 2 end
ikc3> Example.double(21)
42
ikc3> Example.double_tuple(:ok)
{:ok, :ok}
ikc3> double 21
42
```

## Facts

Le module Facts (faits) permet un acces en lecture et en Ã©criture vers
une base de donnÃ©es en graphe contenant des faits : des triplets sujet,
relation, objet.

Des exemples pour faire des requÃªtes sur la base de donnÃ©es de KC3
contenant toutes les dÃ©finitions de l'interpreteur :

```elixir
ikc3> Facts.with_tags(Facts.env_facts(), KC3, :op, ?,
        fn (fact) { puts(fact.object); :ok })
operator_eq
operator_gt
operator_lt
[...]
:ok
```

---

Top : [KC3 Guides](./)

Previous : [Guide de la structure de KC3](3.4_Structure)
