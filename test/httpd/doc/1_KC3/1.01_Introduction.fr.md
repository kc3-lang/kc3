# 1.1 Introduction

KC3 est actuellement un projet de langage de programmation inspiré
du C, d'Elixir et de Common Lisp. Il pourrait être décrit comme
du C avec des modules Elixir, du filtrage par motifs et un système
d'objets sémantiques. L'idée est d'intégrer des modules, des
fermetures (closures), du filtrage par motifs (pattern-matching),
une base de données en graphes et de la métaprogrammation dans
C11 avec un nombre extrêmement réduit de dépendances.

Systèmes d'exploitation pris en charge (dépendances supplémentaires) :
- BSD
- Linux (libbsd, libmd)
- MacOS X (libmd)
- Windows (MSys2)

Architectures prises en charge :
- aarch64 (arm64, Apple M1, Apple M2)
- amd64
- i386
- sparc64

## 1.1.1 Modules

Dans KC3, tout est organisé dans des modules. Un module est un espace
de noms et son nom est un symbole commençant par une majuscule. Par
exemple, `Sym` et `Str` sont des noms de module valides.

Utilisez defmodule pour définir un module.

## Exemple :
```elixir
defmodule Test do
  def one = 1
  def double = fn (x) { x * 2 }
  def add = cfn Tag "tag_add" (Tag, Tag, Result)
end
```
Chaque module peut définir un type, et un nom de module peut également
être un nom de type si le module correspondant définit un type.

Utilisez defstruct pour définir un type de structure dans un module.
La structure portera le même nom que le module.

## Exemple :
```elixir
ikc3> defmodule Test do
ikc3>   defstruct [x: (F32) 0.0,
ikc3>              y: (F32) 0.0]
ikc3> end
ikc3> a = %Test{}
%Test{x: (F32) 0.0,
      y: (F32) 0.0}
ikc3> a.x
(F32) 0.0
ikc3> a.y
(F32) 0.0
```
Le module peut également inclure des définitions de constantes ou de fonctions pour opérer sur le type de module ou d’autres types.

Le module par défaut est KC3, défini comme des faits (triplets)
dans lib/kc3/0.1/kc3.facts.

## 1.1.2 Types de données

Les types de données de base dans KC3 sont :
 - Chaînes : `Str`, par exemple `"Bonjour, monde !"`
 - Symboles : `Sym`, par exemple `:hello` ou `Hello`
 - Booléens : `Bool`, `true` (vrai) ou `false` (faux)
 - Nombres
   - Entiers
     - Petits entiers
       - Petits entiers signés : `S8`, `S16`, `S32`, `S64`, `Sw`
       - Petits entiers non signés : `U8`, `U16`, `U32`, `U64`, `Uw`
     - Grands entiers : `Integer`
   - Nombres rationnels (fractions d'entiers) : `Ratio`,
     par exemple `-2/3`
   - Nombres à virgule flottante : `F32`, `F64`, `F128`
   - Nombres complexes (i = √(-1)) : `Complex`, par exemple `1 +i 2`
 - Listes : `List`, par exemple `[1, 2, 3]`
 - Tuples : `Tuple`, par exemple `{:ok, 123}`
 - Maps : `Map`, par exemple `%{id: 1, login: "dx"}`
 - Structures : `Struct`, par exemple `%GL.Sphere{}`
 - Code partiellement evalué : `Quote`, par exemple `quote 1 + 2`,
   et `Unquote()`, par exemple : `quote 1 + unquote(b)`
 - Identifiants : `Ident`, par exemple `quote List.map`
 - Appel de fonction ou d'opérateur : `Call`, par exemple
   `quote sqrt(1)`, `quote 1 + 2`
 - Blocs de code : Bloc, p. ex. { 1 + 2; 3 + 4 }
 - Fonction : `Fn`, par exemple `fn (x) { x * 2 }`
 - Fonction C : `Cfn`, par exemple
   `cfn Tag "tag_add" (Tag, Tag, Résultat)`
 - Variables : `Var`, par exemple `(U8) ?`
 - Void : `Void`, type qui a pour seule valeur `void`

---

Haut : [KC3 documentation](../)

Précédent : [1 KC3](./)

Suivant : [1.02 Array](1.02_Array)
