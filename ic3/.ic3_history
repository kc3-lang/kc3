Plop.sq(4)
defmodule Plop do defoperator :operator_add :+ cfn Tag "tag_mul" (Tag, Tag, Result) 10 :left end
defmodule Plop do
  def sq = fn (x) { x + x }
end
Plop.sq(4)
defmodule Plop do def a = 1 end
Plop.a
(Sw) 123\
(Sw) 123
(Sw) 123/2
(Sw) 123 / 2
defmodule Plop do def a = 1 end
Plop.a
defmodule Plop do def a = 2 end
Plop.a
defmodule Plop do def a = 1; def double = fn (x) { x * 2 } end
Plop.a
Plop.double
Plop.double(21)
def a = 1
a
def double = fn (x) { x * 2 }
double(42)
defmodule Tiyon do
  def a = 1
  def double = fn (x) { x * 2 }
  def double_tuple = macro (x) do {x, x} end
  def double_list = macro (x) do [x, x] end
end
Tiyon.a
Tiyon.double(21)
Tiyon.double_tuple(21)
Tiyon.double_tuple(21 + 21)
Tiyon.double_list(21 + 21)
[42, x] = Tiyon.double_list(21 + 21)
[42, x] = [42, 42]
x
Tiyon.double_list(21 + 21) = [42, y]
def last = fn (x) do
  [y | _] = List.reverse(x)
  y
end
def last = fn (x) do
  [y | _] = List.reverse(x)
  y
end
def List.last = fn (x) do
  [y | _] = List.reverse(x)
  y
end
List.last([1, 2, 3, 4])
def List.last = fn (x) do
  [y | z] = List.reverse(x)
  y
end
List.last([1, 2, 3, 4])
[x, y | z] = List.reverse([1, 2, 3])
x
y
z
[x, y | z] = List.reverse([1, 2, 3, 4])
x
y
z
if true then true end
if 42 then true end
if 0 then true end
if 0 then true else false end
List.map
List.map([1, 2, 3], fn (x) { x * 2 })
List.reverse
List.reverse([1, 2, 3])
List.reverse
List.reverse([1, 2])
def a = 1
a
module()
defmodule Plop do
  def m = fn () { module() }
end
Plop.m()
module()
List.reverse([1, 2, 3])
List.reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
(List) {1, 2}
?
cow 1
(Tag) cow 1
a = cow 1
a
a + 1
cow 1
type(cow 1)
cow 1 + cow 1
cow(1) + cow(1)
quote [a: 1, b: 2]
quote [{:a, 1}, {:b, 2}]
%C3.Operator{}
