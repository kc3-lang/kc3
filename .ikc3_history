type(12345)
type(123456)
type(123456789)
type(123456789012)
type(1234567890123456789)
type(123456789012345678901234)
type(123456789012345678901234/2)
123456789012345678901234/2
123456789012345678901234/2 * 0.1
(123456789012345678901234/2) * 0.1
(F128) 123456789012345678901234/2 * 0.1
List.to_array
0 - 2
Tuple[]
type(Tuple[])
type((Tuple[]) {{1, 2, 3}})
type((Tuple[]) {1, 2, 3})
[1][0]
([1])[0]
access([1, 2, 3], 2)
access([1, 2, 3], [2])
access([1, 2, 3], [0])
access([1, 2, 3], [1])
access([1, 2, 3], [2])
access([1, 2, 3], [3])
a = [1, 2, 3]
a[0]
a[1]
a[2]
a[3]
points = [{(F128) 0, (F128) 1}, {(F128) 0.5, (F128) 0.6}]
points[0]
points[1]
points[2]
points[3]
points
points = [{(F128) 0, (F128) 1}, {(F128) 0.5, (F128) 0.6}]
points
points[3]
points[0]
points[1]
points[2]
"#{(F128) 0.0}"
"#{(F128) 0.1}"
List.map([1, 2, 3], fn (x) { x * 8 })
1 + 1
1 + 1000000000000000000000000000000000000000000000000000000000
type(1 + 1000000000000000000000000000000000000000000000000)
type(1 + 1)
type(255)
type(256)
type(255 + 1)
F128.pi
F128.cos(2 * F128.pi)
F128
type(F128)
:F128
type(:F128)
:F128 == F128
F128.cos
(F128) 0.1 + (F128) 0.1
(F128) 0.01 + (F128) 0.01
(F64) 0.01 + (F64) 0.01
(F64) 0.001 + (F64) 0.001
(F64) 0.0001 + (F64) 0.0001
(F64) 0.00001 + (F64) 0.00001
(F64) 0.000001 + (F64) 0.000001
(F64) 0.000002 + (F64) 0.000002
(F64) 0.0000002 + (F64) 0.0000002
(F64) 0.0000001 + (F64) 0.0000001
(F64) 0.000001 + (F64) 0.000003
(F64) 0.3 + (F64) 0.3
type(0.1)
0.1 + 0.1
0.01 + 0.01
1 / 3
1.0 / 3.0
1 mod 3
1/3
(F64) 1.0 / (F64) 3.0
1/3
1/3 * 2
1/3 * 2 * 3
(Integer) (1/3 * 2 * 3)
type((Integer) (1/3 * 2 * 3))
type((U8) (1/3 * 2 * 3))
(U8) (1/3 * 2 * 3)
"abc" + "def"
"abc#{123}" + "def"
"abc#{123 + 456}" + "def"
"abc#{(Uw) 123 + 456}" + "def"
(Uw) 123 + 456
(Uw) (123 + 456)
"abc#{(Uw) (123 + 456)}" + "def"
quote if true do %{plop: 123, hop: 456} end
pid
pid()
man getpid
t = Thread.new(fn () { puts("ok") })
