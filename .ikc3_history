s.st_mtim
List.to_array
a = %KC3.Op{sym: :dot, callable: fn (a, b) { a.x * b.y + a.y * b.y }}
block :abc do
  return 1
end
block :abc do
  return 1
  123
end
block :abc do
  return_from :abc 1
  123
end
block :abc do
  return_from :abc 1 + 1
  123
end
a = fn (x) { return x * 2 ; 3 }
a(1)
a = fn (x) { return (x * 2)
3
}
a(1)
a = fn (x) { return x * 2 ; 3 }
a(3)
a = fn (x) { return (x * 2) ; 3 }
a(3)
a = fn (x) { return x * 2
3
}
a(3)
quote x * 2; 3
a = fn (x) {
  return x * 3
  1
}
a(2)
a = fn (x) {
  return_from :a x * 3
  1
}
a(3)
block :abc do
  123
  return 2
  1
end
block :abc do
  123
  return_from :abc 2
  1
end
block :abc do
  if 2 > 4 do
    return -1
  else
	  return 1
  end
end
f = fn (x) {
  if (x > 4) do
    return -1
  else
	  return 1
  end
}
f(4)
f(5)
unwind_protect {
unwind_protect({
  puts("a")
  1
}, puts("b"))
}
block :a unwind_protect(do
  puts("a")
  return_from :a 1
  2
end
, puts("b")
)
ncpu
defmodule Test do
  defstruct [hello: "World !",
             id: 1337]
end
%Test{}
t = %Test{}
type(test.id)
type(t.id)
defmodule Test do
  defstruct [hello: "World !",
             id: (S64) 123]
end
t
type(t.id)
t = %Test{}
type(t.id)
